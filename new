from flask import Flask, render_template, request, Response
import subprocess
import time
import requests
import threading
import os
import signal
import multiprocessing
import werkzeug.serving


app = Flask(__name__)

# manager = multiprocessing.Manager()
# DB = {}
PORTS_USED = set()
WATCHER_INTERVAL = 30  # Check every 30 seconds
TIMEOUT = 60   # Timeout of 1 minutes
port_watcher_lock = multiprocessing.RLock()

# Set the port_watcher_running event to False to start with
port_watcher_running = multiprocessing.Event()
port_watcher_running.clear()

def get_free_port():
    global PORTS_USED
    for port in range(9000, 10000):
        if port not in PORTS_USED:
            PORTS_USED.add(port)
            return port
    return None

def start_new_target_app():
    free_port = get_free_port()
    if free_port is None:
        return None, None
    timestamp = time.time()
    cmd = ["node", "Server/server.js", str(free_port)]

    process = subprocess.Popen(cmd, cwd="target_app")
    print(f"New target_app started on port {free_port} with process id {process.pid}")
    time.sleep(2)
    return free_port, process, timestamp

def cleanup_process(email):
    global DB
    print ("here")
    if email in DB:
        port = DB[email]["port"]
        pid = DB[email]["pid"]
        process = DB[email].get("process")
        if process and process.poll() is None:
            try:
                os.kill(pid, signal.SIGTERM)
                print(f"Process with PID {pid} terminated for email {email}.")
            except ProcessLookupError:
                print(f"Process with PID {pid} has already terminated for email {email}.")
            except Exception as e:
                print(f"Error terminating process with PID {pid} for email {email}: {e}")


        del DB[email]
        PORTS_USED.remove(port)
        print(f"Cleanup complete for email {email} on port {port}")

def port_watcher(DB):
    # global DB
    while not port_watcher_running.is_set():
       
        print("Running port watcher...")
        now = time.time()
        with port_watcher_lock:
            if not DB:  # Check if DB is empty
                print("DB is empty")
            else:
                print(f"length = {len(DB.items())}")
            for email, info in list(DB.items()):
                timestamp = info.get("timestamp", 0)
                print(f"timestamp left {now - timestamp}")
                if now - timestamp > TIMEOUT:
                    cleanup_process(email, DB)
        # Use time.sleep() to avoid tight looping
        time.sleep(WATCHER_INTERVAL)
    print("port_watcher thread stopped")

def cleanup_all_processes(signum, frame):
    global DB
    # Cleanup all processes and clear the DB and PORTS_USED
    for email in list(DB.keys()):
        cleanup_process(email)
    DB.clear()
    PORTS_USED.clear()
    # Stop the development server gracefully
    werkzeug.serving.HaltServer.halt = True

@app.route("/", methods=["GET", "POST"])
def index():
    global DB
    if request.method == "POST":
        email = request.form.get("email")
        if email not in DB:
            port, pid, timestamp = start_new_target_app()
            if port and pid:
                DB[email] = {
                    "port": port,
                    "pid": pid,
                    "timestamp": timestamp
                }
                print(f"New entry added to DB for email {email}")
            else:
                return "No free ports available at the moment. Please try again later.", 500
        else:
            # If the email already exists, update the "timestamp"
            DB[email]["timestamp"] = time.time()

        port = DB[email]["port"]
        if not DB:  # Check if DB is empty
            print("DB is empty index")
        else:
            print(f"length index= {len(DB.items())}")
        response = requests.get(f"http://localhost:{port}")
        if response.status_code == 200:
            return render_template("tic-tac-toe.html", port=port)
        else:
            print("error")
            return f"Failed to get data from localhost:{port}", 500

    else:
        # Check if any processes have timed out and remove them from the DB
        now = time.time()
        for email, info in list(DB.items()):
            timestamp = info.get("timestamp", 0)
            if now - timestamp > TIMEOUT:
                cleanup_process(email)
        print("memory is cleared and index.html should open now")
        return render_template("index.html")

if __name__ == "__main__":
    # multiprocessing.freeze_support()
    manager = multiprocessing.Manager()
    DB = manager.dict()

    watcher_process = multiprocessing.Process(target=port_watcher, args=(DB,))
    watcher_process.start()

    # Register the signal handler to cleanup processes on termination
    signal.signal(signal.SIGINT, cleanup_all_processes)

    try:
        # Start the Flask app
        app.run(debug=True, port=5001, host="0.0.0.0")
    finally:
        # Stop the port_watcher process gracefully
        watcher_process.terminate()
        watcher_process.join()